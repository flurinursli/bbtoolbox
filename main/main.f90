PROGRAM main

  ! Purpose:
  !   to invert coda waves and return best fitting model parameters based on RTT. Sampling of parameters space relies on the NA by
  !   Sambridge. The following inversion setups are possible:
  !
  !     a) inversion of each single coda recorded by a receiver
  !     b) single inversion of all coda recorded by a receiver
  !     c) single inversion of coda generated by the same event and recorded by a group of receivers
  !
  !   The code read recordings in miniseed ASCII format, filter and downsample them, extract envelope and then run the inversion. It
  !   is assumed that recordings first time sample corresponds to earthquake origin time, the latter being set to zero (P/S-wave
  !   arrival times must be based on this convention).
  !
  ! Revisions:
  !     Date                    Description of change
  !     ====                    =====================
  !   18/12/20                  original version
  !
! mpirun -np 1 -x OMP_NUM_THREADS=8 --bind-to socket ./debug.exe deby.par


#ifdef MPI
  USE, NON_INTRINSIC :: mpi
#endif
  USE, NON_INTRINSIC :: m_precisions
  USE, NON_INTRINSIC :: m_toolbox
  USE, NON_INTRINSIC :: m_source
  USE, NON_INTRINSIC :: m_logfile
  USE, NON_INTRINSIC :: m_strings
  USE, NON_INTRINSIC :: m_noise
  USE, NON_INTRINSIC :: m_rik
  USE, NON_INTRINSIC :: m_timeseries

  IMPLICIT none

  INTEGER(i32)              :: ierr, rank, ntasks, ok, i0, i1, iter, irec, pl, ivel
  REAL(r64),   DIMENSION(2) :: tictoc

  !---------------------------------------------------------------------------------------------------------------------------------

  rank   = 0
  ntasks = 1

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --
  ! ----------------------------------------------------- initialization -----------------------------------------------------------

#ifdef MPI
  CALL mpi_init(ierr)
  CALL mpi_comm_rank(mpi_comm_world, rank, ierr)
  CALL mpi_comm_size(mpi_comm_world, ntasks, ierr)
#endif

  CALL watch_start(tictoc(1))

  ! IF (world_rank .eq. 0) CALL set_log_module(ok, screen = .true.)
  CALL set_log_module(ok, screen = .true., errclr = 'red')      !< errors are printed in red

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --
  ! --------------------------------- read main input file and stop execution if error is raised -----------------------------------

  CALL read_input_file(ok, rank, ntasks)

#ifdef MPI
  IF (ok .ne. 0) CALL mpi_abort(mpi_comm_world, ok, ierr)
#else
  STOP
#endif

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --
  ! ------------------------------------------------- setup the source model  ------------------------------------------------------

  CALL setup_source(ok, rank, ntasks)

#ifdef MPI
  IF (ok .ne. 0) CALL mpi_abort(mpi_comm_world, ok, ierr)
#else
  STOP
#endif

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --
  ! ------------------------------------------------- load input time-series  ------------------------------------------------------

  ! CALL read_lp(ok, rank, ntasks)

#ifdef MPI
  IF (ok .ne. 0) CALL mpi_abort(mpi_comm_world, ok, ierr)
#else
  STOP
#endif

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --
  ! ------------------------------------------------------- time stuff -------------------------------------------------------------

  timeseries%sp%dt = 0.25_r32 / input%coda%fmax             !< fnyq must be twice fmax

  pl = NINT(40. / timeseries%sp%dt)
  ALLOCATE(timeseries%sp%time(pl))

  do i0 = 1, pl
    timeseries%sp%time(i0) = (i0 - 1)*timeseries%sp%dt
  enddo

  ALLOCATE(timeseries%sp%x(pl, SIZE(input%receiver)), timeseries%sp%y(pl, SIZE(input%receiver)),   &
           timeseries%sp%z(pl, SIZE(input%receiver)))

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --
  ! --------------------------------------------- generate coda with random phase --------------------------------------------------

  CALL generate_noise(ok, rank)

#ifdef MPI
  IF (ok .ne. 0) CALL mpi_abort(mpi_comm_world, ok, ierr)
#else
  STOP
#endif

  ! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --
  ! ---------------------------------------------------- start simulations ---------------------------------------------------------

  CALL split_task(input%source%samples, ntasks, rank, i0, i1)

  DO iter = i0, i1            !< every iteration is characterized by different source properties (rik, roughness)

    DO pl = 1, SIZE(plane)

      DO ivel = 2, SIZE(input%velocity)

        CALL update_log(num2char('Iteration for', width=30, fill='.') + num2char('Source #', width=15, justify='r') + '|' +   &
                        num2char('Segment #', width=15, justify='r') + '|' + num2char('Velocity #', width=15, justify='r') + '|')

        CALL update_log(num2char('', width=30) + num2char(iter, width=15, justify='r') + '|' +  &
                        num2char(pl, width=15, justify='r') + '|' + num2char(ivel, width=15, justify='r') + '|', blankline=.false.)

        CALL meshing(pl, ivel)
        !CALL roughness(pl, iter)

        CALL rik(ok, pl, ivel, iter)

        DO irec = 1, SIZE(input%receiver)
          !IF (input%receiver(irec)%velocity .eq. ivel) CALL quake(irec, pl)
        ENDDO

      ENDDO

    ENDDO

    DO irec = 1, SIZE(input%receiver)
      !CALL add_coda(irec)
      !CALL stitch(irec)
      !CALL save2disk(irec, iter)
    ENDDO

  ENDDO

  CALL watch_stop(tictoc(1))

  tictoc = tictoc / 60._r32

  IF (rank .eq. 0) CALL update_log('Program completed in' + num2char(tictoc(1), notation='f', width=10, precision=1) + ' minutes')

END PROGRAM main

! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * ---
!===================================================================================================================================
! --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * --- * ---
